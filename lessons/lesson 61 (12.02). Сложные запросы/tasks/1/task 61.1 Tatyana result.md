Время затраченное на выполнение: 1:37

result: 50/100

1) **Сильные стороны**
- Созданы таблицы `Customers` и `Orders` с правильными полями, включая первичные ключи, внешний ключ и автоинкремент.
- Данные вставлены корректно, соответствуют примеру из условия.
- Первый запрос (INNER JOIN) точно соответствует требованию уровня 1.
- Использованы правильные типы JOIN (LEFT JOIN для уровня 2) и UNION для объединения.
- Код структурирован, есть комментарии, разделяющие уровни.

2) **Ошибки и недочёты**

**Блокирующие (ломает выполнение требований задания)**
- **Уровень 3: запрос некорректен.** В условии требуется найти заказы, для которых нет соответствующего клиента. Для этого нужно сравнить набор данных из `Orders` с результатом соединения `Orders` и `Customers`. В решении используется `EXCEPT`, но сравниваются несовместимые наборы полей: первый `SELECT` берёт поля из `Orders` (OrderID, CustomerID, OrderDate, TotalAmount), а второй `SELECT` берёт поля из `Customers` (CustomerID, FirstName, LastName, Email). Это приведёт к ошибке выполнения или бессмысленному результату, так как количество и типы столбцов в частях `EXCEPT` должны совпадать. Запрос не выполняет поставленную задачу.
  - Место: последний блок кода после `--[запрос B]`.
  - Исправление: нужно либо использовать `LEFT JOIN` с проверкой на NULL, либо корректный `EXCEPT` с одинаковыми столбцами. Пример исправления:
    ```sql
    SELECT Orders.OrderID, Orders.CustomerID, Orders.OrderDate, Orders.TotalAmount
    FROM Orders
    LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID
    WHERE Customers.CustomerID IS NULL;
    ```
    Или через `EXCEPT` (менее интуитивно):
    ```sql
    SELECT OrderID, CustomerID, OrderDate, TotalAmount FROM Orders
    EXCEPT
    SELECT Orders.OrderID, Orders.CustomerID, Orders.OrderDate, Orders.TotalAmount
    FROM Orders
    INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
    ```

**Значимые (может дать неверный результат на части кейсов, сильно ухудшает качество)**
- **Проверка формата даты некорректна.** В таблице `Orders` для поля `OrderDate` указано `CHECK (OrderDate is date(OrderDate))`. Это выражение всегда верно для любого текста, так как функция `date()` в SQLite возвращает NULL для невалидной даты, а `NULL IS date(...)` даёт NULL (не FALSE), поэтому проверка не работает. Это может привести к хранению некорректных данных.
  - Место: строка `OrderDate TEXT CHECK (OrderDate is date(OrderDate))`.
  - Исправление: использовать `CHECK (date(OrderDate) IS NOT NULL)` или явную проверку формата регулярным выражением (если поддерживается). Простейшее исправление: `CHECK (OrderDate IS date(OrderDate) AND OrderDate IS NOT NULL)`, но лучше: `CHECK (date(OrderDate) IS NOT NULL)`.

**Минорные (стиль, читаемость, мелкие улучшения без влияния на правильность)**
- **Избыточные DROP TABLE.** В начале файла есть `DROP TABLE Orders; DROP TABLE Customers;`. Хотя это не запрещено, в условии не требовалось очищать базу. Это может вызвать ошибку при первом запуске, если таблиц не существует (в SQLite это предупреждение, но лучше использовать `DROP TABLE IF EXISTS`).
  - Место: первые две строки.
  - Исправление: добавить `IF EXISTS` или убрать, если не требуется.
- **Несоответствие псевдокоду уровня 2.** В псевдокоде для "запроса B" описано объединение двух частей: первая часть выбирает данные клиентов с пустыми OrderID и TotalAmount, вторая — данные заказов с пустыми FirstName и LastName. В решении же вторая часть выбирает `NULL, NULL, OrderID, TotalAmount`, что соответствует псевдокоду, но первая часть выбирает `FirstName, LastName, NULL AS OrderID, NULL AS TotalAmount` — это корректно. Однако в псевдокоде указано "объединить результаты частей без дубликатов", что подразумевает `UNION`, а студент использовал `UNION` (что верно). Несоответствие минимальное, но можно отметить, что в псевдокоде первая часть включает "пустой OrderID, пустую TotalAmount", а вторая — "пустые FirstName и LastName", что и сделано.
- **Отсутствие упорядочивания результатов.** В условии не требовался определённый порядок, но для читаемости можно добавить `ORDER BY` в запросы, особенно в UNION.

3) **Оценка и как она посчитана**
- **Функциональность и соответствие условию: 25/50**
  - Уровень 1 выполнен полностью: +20 баллов.
  - Уровень 2 выполнен: запрос A (LEFT JOIN) корректен, запрос B (UNION) корректен: +20 баллов.
  - Уровень 3 не выполнен: запрос ошибочный, не решает задачу: 0 баллов.
  - Итого: 40 баллов за уровни 1 и 2, но из-за блокирующей ошибки в уровне 3 снимаем 15 баллов (так как уровень 3 — продвинутый, его невыполнение существенно). Финально: 25/50.
- **Качество кода: 20/30**
  - Структура хорошая, читаемость приемлемая: +15.
  - Ошибка с CHECK-ограничением снижает устойчивость: -5.
  - Избыточные DROP TABLE без IF EXISTS: -2.
  - Некорректный запрос уровня 3 снижает общее качество: -3.
  - Итого: 20/30.
- **Стиль и тесты: 5/20**
  - Стиль: код отформатирован, есть комментарии, имена понятны: +10.
  - Тесты не требовались и не предоставлены: 0.
  - Из-за ошибки в уровне 3 (логическая ошибка) сильно страдает корректность, что влияет на общее впечатление: -5.
  - Итого: 5/20.

**Общий итог: 25 + 20 + 5 = 50/100.**

4) **Если задание выполнено не полностью**
- **Отсутствует:** корректная реализация уровня 3 (поиск заказов без клиентов).
- **Сделано частично:** уровень 3 формально присутствует, но запрос нерабочий.

**Вариант полного решения для уровня 3:**
Код (дополнение к решению студента, заменяет последний SELECT):
```sql
-- Уровень 3: Найти заказы, для которых нет соответствующего клиента
SELECT Orders.OrderID, Orders.CustomerID, Orders.OrderDate, Orders.TotalAmount
FROM Orders
LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID
WHERE Customers.CustomerID IS NULL;
```
Или, если хочется сохранить подход с EXCEPT:
```sql
SELECT OrderID, CustomerID, OrderDate, TotalAmount FROM Orders
EXCEPT
SELECT Orders.OrderID, Orders.CustomerID, Orders.OrderDate, Orders.TotalAmount
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
```
Также рекомендуется исправить CHECK на `CHECK (date(OrderDate) IS NOT NULL)` и добавить `IF EXISTS` в DROP TABLE.
