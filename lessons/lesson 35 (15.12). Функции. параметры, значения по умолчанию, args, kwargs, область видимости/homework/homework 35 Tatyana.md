# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи
1.  **Функция для форматирования данных о товаре**
    -   **Описание задачи:** Тренировка объявления функций, использования позиционных и именованных аргументов, а также оператора `return`. Задача учит четко разделять логику обработки данных (внутри функции) и вывод результата (снаружи). Это фундаментальный навык для написания переиспользуемого кода.
    -   **Пример (вход → выход):**
        -   `format_product("Ноутбук", 89999, "шт.")` → `"Ноутбук: 89999 руб./шт."`
        -   `format_product(price=150, name="Молоко", unit="л")` → `"Молоко: 150 руб./л"`
        -   `format_product("Книга", 500)` → `"Книга: 500 руб./шт."` (используется значение по умолчанию для `unit`)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `format_product`.
        -   Она должна принимать три параметра: `name` (название), `price` (цена), `unit` (единица измерения).
        -   Параметр `unit` должен иметь значение по умолчанию `"шт."`.
        -   Функция должна **возвращать** строку в формате `"{name}: {price} руб./{unit}"`.
        -   Не используй `print` внутри функции для вывода результата.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `format_product` с параметрами `name`, `price` и `unit` (последнему задай значение по умолчанию).
        2.  Внутри функции создай строку `result`, объединив значения параметров в нужном формате.
        3.  Верни строку `result` с помощью оператора `return`.
    -   **Рекомендации:**
        -   **PEP8:** Имя функции должно быть в `snake_case`. После объявления функции оставь две пустые строки перед следующим блоком кода.

2.  **Безопасное добавление заметок в дневник**
    -   **Описание задачи:** Закрепление понимания ловушки изменяемых значений по умолчанию (списков, словарей). Задача учит использовать паттерн с `None` для безопасной инициализации изменяемых коллекций внутри функции, предотвращая неожиданное поведение при повторных вызовах.
    -   **Пример (вход → выход):**
        -   Первый вызов: `add_note("Купить хлеб")` → `['Купить хлеб']`
        -   Второй вызов: `add_note("Позвонить маме")` → `['Позвонить маме']` (а не `['Купить хлеб', 'Позвонить маме']`!)
        -   С передачей своего списка: `my_notes = ["Старая заметка"]`; `add_note("Новая заметка", my_notes)` → `['Старая заметка', 'Новая заметка']`
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `add_note`.
        -   Она должна принимать два параметра: `note_text` (текст заметки) и `diary` (список заметок).
        -   Параметр `diary` должен иметь значение по умолчанию `None`.
        -   Если `diary` равен `None`, внутри функции нужно создать новый пустой список.
        -   Функция должна добавить `note_text` в список `diary` и вернуть этот список.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `add_note` с параметрами `note_text` и `diary` (со значением по умолчанию `None`).
        2.  Внутри функции проверь, равен ли `diary` `None`.
        3.  Если да, создай новый пустой список и присвой его переменной `diary`.
        4.  Добавь `note_text` в список `diary`.
        5.  Верни список `diary`.
    -   **Рекомендации:**
        -   Для проверки на `None` используй оператор `is` (например, `if diary is None:`).
        -   **PEP8:** Используй отступ в 4 пробела для тела функции и блоков `if`.

3.  **Универсальный калькулятор счета в кафе**
    -   **Описание задачи:** Практика работы с `*args` для обработки переменного числа аргументов. Задача развивает навык написания гибких функций, которые могут работать с заранее неизвестным количеством данных — типичная ситуация при обработке списков цен.
    -   **Пример (вход → выход):**
        -   `calculate_total(150, 200, 85)` → `435` (сумма всех переданных цен)
        -   `calculate_total(50)` → `50`
        -   `calculate_total()` → `0` (обработка граничного случая)
        -   С распаковкой списка: `order = [300, 120, 80]`; `calculate_total(*order)` → `500`
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `calculate_total`.
        -   Она должна принимать произвольное количество позиционных аргументов (цены на позиции в заказе) с помощью `*args`.
        -   Функция должна возвращать сумму всех переданных аргументов.
        -   Если аргументы не переданы, функция должна вернуть `0`.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `calculate_total`, которая принимает `*args`.
        2.  Внутри функции просуммируй все элементы кортежа `args`. Учти, что `args` может быть пустым.
        3.  Верни полученную сумму.
    -   **Рекомендации:**
        -   Встроенная функция `sum()` умеет работать с пустыми коллекциями и вернет `0`.
        -   **PEP8:** Параметр `*args` является общепринятым именем для сбора позиционных аргументов, менять его не нужно.

4.  **Сборник рецептов с метаданными**
    -   **Описание задачи:** Интеграция нескольких концепций: именованные аргументы, `**kwargs` для сбора произвольных метаданных, значения по умолчанию и область видимости. Задача моделирует создание структуры данных (словаря рецептов) с помощью функций, что приближено к реальным сценариям.
    -   **Описание задачи:** Создай функцию для добавления рецепта в кулинарную книгу. Каждый рецепт имеет обязательное название и время приготовления, а также может содержать произвольные дополнительные метаданные (например, сложность, кухня, список ингредиентов как строка).
    -   **Пример (вход → выход):**
        ```python
        cookbook = {}
        add_recipe(cookbook, "Омлет", time=10, difficulty="легко", ingredients="яйца, молоко, соль")
        add_recipe(cookbook, "Борщ", time=120, cuisine="русская")
        # cookbook теперь содержит:
        # {
        #   "Омлет": {"time": 10, "difficulty": "легко", "ingredients": "яйца, молоко, соль"},
        #   "Борщ": {"time": 120, "cuisine": "русская"}
        # }
        ```
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `add_recipe`.
        -   Она должна принимать три параметра: `book` (словарь-кулинарная книга), `name` (название рецепта) и `time` (время приготовления).
        -   Параметр `time` должен быть обязательным и не иметь значения по умолчанию.
        -   Функция должна принимать произвольное количество именованных аргументов (метаданные) через `**kwargs`.
        -   Функция должна добавить в словарь `book` новую запись, где ключ — это `name`, а значение — словарь, содержащий `"time": time` и все пары ключ-значение из `**kwargs`.
        -   Функция не должна ничего возвращать (изменяет переданный словарь `book`).
    -   **Решение (псевдокод):**
        1.  Объяви функцию `add_recipe` с параметрами `book`, `name`, `time` и `**kwargs`.
        2.  Создай словарь `recipe_details`.
        3.  Добавь в `recipe_details` ключ `"time"` со значением параметра `time`.
        4.  Обнови словарь `recipe_details` содержимым словаря `kwargs`.
        5.  Добавь в переданный словарь `book` новую пару: ключ `name`, значение `recipe_details`.
    -   **Рекомендации:**
        -   Для обновления одного словаря содержимым другого используй метод `.update()`.
        -   **Область видимости:** Параметр `book` ссылается на тот же словарь, что и переменная `cookbook` снаружи. Изменяя `book` внутри функции, ты изменяешь глобальный `cookbook`. Использовать `global` в этом случае не требуется и нежелательно.
        -   **PEP8:** Если строка вызова функции с `**kwargs` становится слишком длинной, перенеси аргументы на новую строку с отступом.
