# Практическое задание 35.3

## Задания

### Описание задачи
В предыдущем блоке вы научились работать с позиционными и именованными аргументами, а также значениями по умолчанию. Сейчас вы переходите к изучению функций с переменным числом аргументов. Это умение позволит вам писать более гибкий код, который может обрабатывать заранее неизвестное количество данных — частый случай в реальных задачах.

Ваша задача — создать функцию `collect_data`, которая собирает информацию о товарах в интернет-магазине. Функция должна уметь принимать:
1. Обязательные аргументы: `product_name` (название товара) и `base_price` (базовая цена).
2. Произвольное количество дополнительных цен через `*args` (например, цены в разных валютах или цены от разных поставщиков).
3. Произвольное количество метаданных через `**kwargs` (например, `color="красный"`, `weight=1.5`, `in_stock=True`).

Функция должна возвращать словарь следующей структуры:
```python
{
    "name": product_name,
    "base_price": base_price,
    "all_prices": [base_price, ...],  # список из base_price и всех переданных в *args цен
    "metadata": { ... }  # словарь со всеми переданными в **kwargs парами ключ-значение
}
```

Также создайте вспомогательную функцию `apply_discount`, которая принимает словарь товара (результат работы `collect_data`) и коэффициент скидки `discount` (по умолчанию 0.9, т.е. 10% скидка). Функция должна вернуть новый словарь, в котором все цены в списке `all_prices` умножены на коэффициент `discount`. Исходный словарь товара изменяться не должен.

### Пример входных и выходных данных

**Пример 1: Базовый случай**
```python
# Входные данные для collect_data
product1 = collect_data("Футболка", 1000, 950, 1050, color="синий", size="L")
print(product1)
```
Ожидаемый вывод:
```python
{
    'name': 'Футболка',
    'base_price': 1000,
    'all_prices': [1000, 950, 1050],
    'metadata': {'color': 'синий', 'size': 'L'}
}
```
Пояснение: `product_name="Футболка"`, `base_price=1000`. В `*args` попали значения `950` и `1050`. В `**kwargs` попали пары `color="синий"` и `size="L"`.

**Пример 2: Использование apply_discount**
```python
# Продолжение примера 1
discounted_product = apply_discount(product1, discount=0.8)
print(discounted_product)
```
Ожидаемый вывод:
```python
{
    'name': 'Футболка',
    'base_price': 1000,
    'all_prices': [800.0, 760.0, 840.0],  # 1000*0.8, 950*0.8, 1050*0.8
    'metadata': {'color': 'синий', 'size': 'L'}
}
```
Пояснение: Функция `apply_discount` создала новый словарь, где все цены в списке `all_prices` уменьшены на 20%.

**Пример 3: Распаковка коллекций при вызове**
```python
# Входные данные
extra_prices = [120, 130]
extra_info = {"material": "хлопок", "origin": "Турция"}
product2 = collect_data("Штаны", 2000, *extra_prices, **extra_info)
print(product2)
```
Ожидаемый вывод:
```python
{
    'name': 'Штаны',
    'base_price': 2000,
    'all_prices': [2000, 120, 130],
    'metadata': {'material': 'хлопок', 'origin': 'Турция'}
}
```
Пояснение: Список `extra_prices` распакован в `*args`, словарь `extra_info` распакован в `**kwargs`.

### Критерии проверки и ограничения
1. Функция `collect_data` должна корректно использовать `*args` для сбора дополнительных цен и `**kwargs` для сбора метаданных.
2. Список `all_prices` должен всегда начинаться с `base_price`, за которым следуют все значения из `args`.
3. Функция `apply_discount` не должна изменять исходный словарь товара. Она должна создавать и возвращать новый словарь.
4. В `apply_discount` используйте значение по умолчанию для параметра `discount` (0.9).
5. Не используйте темы из будущих блоков: область видимости, глобальные переменные, `global`, замыкания.
6. Код должен соответствовать PEP8 (проверьте отступы, пробелы вокруг операторов, имена переменных).

### Решение задачи (псевдокод)

**Для функции collect_data:**
1. Объявить функцию с параметрами: product_name, base_price, *args, **kwargs.
2. Создать пустой список для всех цен.
3. Добавить base_price в начало этого списка.
4. Для каждого элемента в args:
   - Добавить этот элемент в список всех цен.
5. Создать словарь результата с ключами:
   - "name" = product_name
   - "base_price" = base_price
   - "all_prices" = созданный список всех цен
   - "metadata" = словарь kwargs
6. Вернуть словарь результата.

**Для функции apply_discount:**
1. Объявить функцию с параметрами: product_dict, discount=0.9.
2. Создать копию словаря product_dict (например, через dict() или .copy()).
3. Получить список цен из скопированного словаря по ключу "all_prices".
4. Создать новый список, где каждый элемент старого списка умножен на discount.
5. Записать новый список обратно в скопированный словарь по ключу "all_prices".
6. Вернуть скопированный и измененный словарь.

### Рекомендации
- Вынести в отдельную функцию: Основную логику по сбору данных и применению скидки уже вынесли в функции `collect_data` и `apply_discount`. Дополнительного вынесения не требуется.
- PEP8:
  - Используйте пробелы вокруг операторов присваивания и арифметических операторов (например, `price * discount`).
  - Имена функций должны быть в `snake_case` и отражать их действие (`collect_data`, `apply_discount`).
